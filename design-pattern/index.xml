<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on Jekst</title><link>/design-pattern/</link><description>Recent content in 设计模式 on Jekst</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2016-{year} Jekst. All Rights Reserved.</copyright><lastBuildDate>Mon, 30 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="/design-pattern/index.xml" rel="self" type="application/rss+xml"/><item><title>设计模式6大原则</title><link>/design-pattern/dp-principle/</link><pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate><guid>/design-pattern/dp-principle/</guid><description>1.单一职责原则（Single Responsibility Principle，简称SRP ） There should never be more than one reason for a class to change.
理解：不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。
总结：一个类只承担一个职责
2.里氏替换原则（Liskov Substitution Principle,简称LSP） Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.
理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。
总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。
3.依赖倒置原则（Dependence Inversion Principle,简称DIP） High level modules should not depends upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.</description></item></channel></rss>