<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程开发 on Jekst</title><link>/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/</link><description>Recent content in 编程开发 on Jekst</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2016-{year} Jekst. All Rights Reserved.</copyright><lastBuildDate>Sun, 12 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Markdown简明教程</title><link>/posts/markdown-syntax/</link><pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/markdown-syntax/</guid><description>1.标题 Markdown支持6种级别的标题，对应html标签 h1 ~ h6,注意符号“#”和“H”之间有空格
# H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 效果：
H1 H2 H3 H4 H5 H6 2.段落 段落没有特殊的格式，直接编写文字就可以，段落的换行是使用两个以上空格加上回车。
也可以使用一个或多个空行。
2.1.字体 *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 效果如下：
斜体文本
斜体文本
粗体文本
粗体文本
粗斜体文本
2.2.分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：
*** * * * ***** - - - ---------- 效果如下：
2.3.删除线 文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</description></item><item><title>brew阿里源配置</title><link>/programming/brew/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/brew/</guid><description>Bash 终端配置 1 # 替换brew.git: 2 cd &amp;#34;$(brew --repo)&amp;#34; 3 git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git 4 # 替换homebrew-core.git: 5 cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34; 6 git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git 7 # 应用生效 8 brew update 9 # 替换homebrew-bottles: 10 echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&amp;#39; &amp;gt;&amp;gt; ~/.bashrc 11 source ~/.bashrc Zsh 终端配置 1 # 替换brew.git: 2 cd &amp;#34;$(brew --repo)&amp;#34; 3 git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git 4 # 替换homebrew-core.git: 5 cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34; 6 git remote set-url origin https://mirrors.</description></item><item><title>Docker Webservice</title><link>/programming/docker-webservice/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/docker-webservice/</guid><description>Mysql
1docker run -d -v /Users/User/data/dbdata:/var/lib/mysql --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=llqwe mysql:latest Redis
1docker run -d --name=redis -p 6379:6379 redis:alpine</description></item><item><title>Docker阿里云镜像配置</title><link>/programming/docker-registry/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/docker-registry/</guid><description>1 { 2 &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://rh3ppqdn.mirror.aliyuncs.com&amp;#34;] 3 }</description></item><item><title>Git常用配置</title><link>/programming/gitconfig/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/gitconfig/</guid><description>1[user] 2 name = 用户名 3 email = 邮箱 4[credential] 5 helper = manager 6 7[alias] 8 st = status 9 co = checkout 10 ci = commit 11 br = branch 12 di = diff 13[url &amp;#34;ssh://git@github.com/&amp;#34;] 14 insteadOf = https://github.com/ 15</description></item><item><title>自定义Docker镜像</title><link>/programming/create-docker-image/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/create-docker-image/</guid><description>以制作redis镜像为例，讲一下docker镜像制作及push到仓库流程
1.编写Dockerfile 1FROMalpine:latest2# install redis3RUN apk add redis 4# expose port5EXPOSE63796# start redis server7CMD [&amp;#34;redis-server &amp;#34;]2.创建镜像 1docker build -t redis:0.0.1 . 3.登陆仓库 1docker login --username=username registry.cn-hangzhou.aliyuncs.com 4.镜像打标签 1 2docker tag redis:0.0.1 registry.cn-hangzhou.aliyuncs.com/jekst/redis:0.0.1 5.上传镜像 1docker push registry.cn-hangzhou.aliyuncs.com/jekst/redis:0.0.1</description></item><item><title>Go语言特性</title><link>/programming/go-feature/</link><pubDate>Sun, 29 Aug 2021 13:23:24 +0800</pubDate><guid>/programming/go-feature/</guid><description>slice 每个切片都指向一个底层数组 每个切片都保存了当前切片的长度、底层数组可用容量 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片 map map是并发不安全的 map遍历的顺序不固定 从map读取一个不存在的key将不会引起panic chan 关闭值为nil的channel会引发panic 关闭值为nil的channel会引发panic 向已经关闭的channel或者nil的channel写数据会引发panic 可以从关闭的channel中读数据 iota iota在const关键字出现时被重置为0 const声明块中每新增一行iota值自增1 简单理解：iota代表了const声明块的行索引（下标从0开始）
defer defer定义的延迟函数参数在defer语句出时就已经确定下来了 defer定义顺序与实际执行顺序相反 defer可以改变return返回值，执行过程是: 保存返回值(若有)—&amp;gt;执行 defer（若有）—&amp;gt;执行ret跳转 申请资源后立即使用defer关闭资源是好习惯 select select语句中除default外，每个case操作一个channel，要么读要么写 select语句中除default外，各case执行顺序是随机的 select语句中如果没有default语句，则会阻塞等待任一case select语句中读操作要判断是否成功读取，关闭的channel也可以读 recover recover必须在defer中执行，并且不能在defer嵌套函数中 这样可以
1func main(){ 2 defer func () { 3 err:=recover() 4 }() 5 panic(&amp;#34;some exception&amp;#34;) 6} 7 嵌套不可以
1func main(){ 2 defer func () { 3 func(){ 4 err:=recover() 5 } 6 }() 7 panic(&amp;#34;some exception&amp;#34;) 8} 9 for range for range语句可以遍历数组、slice、map、chan</description></item></channel></rss>