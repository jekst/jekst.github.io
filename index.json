[{"categories":["编程开发"],"content":"1.标题 Markdown支持6种级别的标题，对应html标签 h1 ~ h6,注意符号“#”和“H”之间有空格\n  # H1 ## H2 ### H3 #### H4 ##### H5 ###### H6  效果：\nH1 H2 H3 H4 H5 H6 2.段落 段落没有特殊的格式，直接编写文字就可以，段落的换行是使用两个以上空格加上回车。\n也可以使用一个或多个空行。\n2.1.字体   *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___  效果如下：\n斜体文本\n斜体文本\n粗体文本\n粗体文本\n粗斜体文本\n2.2.分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n  *** * * * ***** - - - ----------  效果如下：\n     2.3.删除线 文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n1~~DELETE WORD~~ 效果如下： DELETE WORD\n2.4.脚注 脚注是对文本的补充说明。\nMarkdown 脚注的格式如下:\n [^要注明的文本]\n 示例： 脚注示例1\n3.列表 Markdown 支持有序列表和无序列表。\n3.1.无序列表 无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\n  * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项  显示结果如下：\n 第一项 第二项 第三项   第一项 第二项 第三项   第一项 第二项 第三项  3.2.有序列表 有序列表使用数字并加上 . 号来表示，如：\n  1. 第一项 2. 第二项 3. 第三项  显示结果如下：\n 第一项 第二项 第三项   4.引用 引用是在段落开头使用 \u0026gt; 符号 ，然后后面紧跟一个空格符号：\n1\u0026gt; 引用内容 效果如下：\n 引用内容\n 5.代码 5.1行内代码 行内代码使用反引号（`）把代码包起来：\n `echo \u0026ldquo;Hello world!\u0026quot;`\n 显示效果：echo \u0026quot;Hello world!\u0026quot;\n5.2代码块 代码块使用三个反引号（```）包裹一段代码：并指定一种语言（也可以不指定）：\n  1 fun Add(a,b int) int { 2 return a+b 3 } 显示效果：\n1 fun Add(a,b int) int { 2 return a+b 3 } 6.链接 链接使用方法如下：\n  [链接名称](链接地址) 或者 \u0026lt;链接地址\u0026gt;  例如：\n 打开[百度](https://www.baidu.com/)\n 打开百度 7.图片 Markdown 图片语法格式如下：\n  ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026quot;可选标题\u0026quot;)  8.表格 表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下：\n  | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 |     表头 表头     单元格 单元格   单元格 单元格    我们可以设置表格的对齐方式：\n -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。  实例如下：\n  | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 |  效果如下：\n   左对齐 右对齐 居中对齐     单元格 单元格 单元格   单元格 单元格 单元格      这是一个脚注示例\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-09-12","img":"/images/markdown.png","permalink":"/posts/markdown-syntax/","series":null,"tags":["Markdown"],"title":"Markdown简明教程"},{"categories":["计算机网络"],"content":"传输控制协议（Transmission Control Protocol，TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，\n1.TCP特点  TCP时面向连接的传输层协议。 TCP只支持一对一通信。 TCP提供可靠交付的服务。通过TCP传送的数据，无差错、不丢失、不重复、并且按序到达。 TCP提供全双工通信。 TCP是面向字节流的。  为满足TCP协议的这些特点，TCP协议做了如下的规定：\n①数据分片：在发送端对用户数据进行分片，在接收端进行重组，由TCP确定分片的大小并控制分片和重组；\n②到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认；\n③超时重发：发送方在发送分片时启动超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片；\n④滑动窗口：TCP连接每一方的接收缓冲空间大小都固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出；\n⑤失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层；\n⑥重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据；\n⑦数据校验：TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验和有差错，TCP将丢弃这个分片，并不确认收到此报文段导致对端超时并重发。\n2.TCP首部格式    0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source Port | Destination Port | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Acknowledgment Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Data | |U|A|P|R|S|F| | | Offset| Reserved |R|C|S|S|Y|I| Window | | | |G|K|H|T|N|N| | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Checksum | Urgent Pointer | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Options | Padding | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | data | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   Source Port是源端口，16位。 Destination Port是目的端口，16位。 Sequence Number是发送数据包中的第一个字节的序列号，32位。 Acknowledgment Number是确认序列号，32位。 Data Offset是数据偏移，4位，该字段的值是TCP首部（包括选项）长度除以4。 标志位： 6位，URG表示Urgent Pointer字段有意义： ACK表示Acknowledgment Number字段有意义 PSH表示Push功能，RST表示复位TCP连接 SYN表示SYN报文（在建立TCP连接的时候使用） FIN表示没有数据需要发送了（在关闭TCP连接的时候使用） Window表示接收缓冲区的空闲空间，16位，用来告诉TCP连接对端自己能够接收的最大数据长度。 Checksum是校验和，16位。 Urgent Pointers是紧急指针，16位，只有URG标志位被设置时该字段才有意义，表示紧急数据相对序列号（Sequence Number字段的值）的偏移。  3.建立连接 TCP使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接。\nTCP三次握手的过程如下：\n 客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。 服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK（ACK=x+1）报文，进入SYN_RECV状态。 客户端收到服务器端的SYN报文，回应一个ACK（ACK=y+1）报文，进入Established状态。  三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。\n4.断开连接 建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。具体过程如下：\n 某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。 注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。  既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。 注意：\n “通常”是指，某些情况下，步骤1的FIN随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。 在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的，这称为“半关闭”（half-close）。 当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。  无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。\n","date":"2021-09-05","img":"","permalink":"/network/tcp/","series":null,"tags":["TCP"],"title":"TCP协议总结"},{"categories":["计算机网络"],"content":"1.UDP概述 用户数据报协议（User Datagram Protocol，UDP），主要有以下特点：\n UDP是无连接的，发送数据前不需要建立连接，结束后也不需要释放链接，因此减少了开销和发送数据之前的延迟 UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维护复杂的连接状态参数。 UDP是面向报文的。 UDP没有拥塞控制。 UDP支持一对一、一对多、多对一、多对多对交互通信。 UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。  2.UDP首部格式    0 7 8 15 16 23 24 31 +--------+--------+--------+--------+ | Source | Destination | | Port | Port | +--------+--------+--------+--------+ | | | | Length | Checksum | +--------+--------+--------+--------+ | | data octets ... +---------------- ...   Source Port 源端口号，在需要对方回信时选用。不需要时可全为0，可选字段。 Destination Port 目的端口号。在终点交付报文时必须要使用到。 Length UDP用户数据报的长度，包括首部和数据长度，其最小值是8（仅有首部）。 Chechsum 校验和，检测UDP用户数据报在传输中是否有错。有错就丢弃。  ","date":"2021-09-05","img":"","permalink":"/network/udp/","series":null,"tags":["UDP"],"title":"UDP协议总结"},{"categories":["编程开发"],"content":"Bash 终端配置 1 # 替换brew.git: 2 cd \u0026#34;$(brew --repo)\u0026#34; 3 git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git 4 # 替换homebrew-core.git: 5 cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; 6 git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git 7 # 应用生效 8 brew update 9 # 替换homebrew-bottles: 10 echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 11 source ~/.bashrc Zsh 终端配置 1 # 替换brew.git: 2 cd \u0026#34;$(brew --repo)\u0026#34; 3 git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git 4 # 替换homebrew-core.git: 5 cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; 6 git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git 7 # 应用生效 8 brew update 9 # 替换homebrew-bottles: 10 echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 11 source ~/.zshrc 12 恢复默认配置 执行以下命令\n1 # 重置brew.git: 2\t$ cd \u0026#34;$(brew --repo)\u0026#34; 3\t$ git remote set-url origin https://github.com/Homebrew/brew.git 4\t# 重置homebrew-core.git: 5\t$ cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; 6\t$ git remote set-url origin https://github.com/Homebrew/homebrew-core.git 7 然后删掉HOMEBREW_BOTTLE_DOMAIN环境变量。\n将你终端文件~/.bashrc 或者~/.zshrc中的HOMEBREW_BOTTLE_DOMAIN行删掉。\n最后执行source ~/.bashrc或者source ~/.zshrc。\n","date":"2021-09-04","img":"","permalink":"/programming/brew/","series":null,"tags":["Brew"],"title":"Brew阿里源配置"},{"categories":["计算机网络"],"content":"   Code Reason-Phrase     100 Continue   101 Switching Protocols   200 OK   201 Created   202 Accepted   203 Non-Authoritative Information   204 No Content   205 Reset Content   206 Partial Content   300 Multiple Choices   301 Moved Permanently   302 Found   303 See Other   304 Not Modified   305 Use Proxy   307 Temporary Redirect   400 Bad Request   401 Unauthorized   402 Payment Required   403 Forbidden   404 Not Found   405 Method Not Allowed   406 Not Acceptable   407 Proxy Authentication Required   408 Request Timeout   409 Conflict   410 Gone   411 Length Required   412 Precondition Failed   413 Payload Too Large   414 URI Too Long   415 Unsupported Media Type   416 Range Not Satisfiable   417 Expectation Failed   426 Upgrade Required   500 Internal Server Error   501 Not Implemented   502 Bad Gateway   503 Service Unavailable   504 Gateway Timeout   505 HTTP Version Not Supported    ","date":"2021-09-04","img":"","permalink":"/network/http-code/","series":null,"tags":["HTTP"],"title":"HTTP响应码"},{"categories":["编程开发"],"content":"Mysql\n1docker run -d -v /Users/User/data/dbdata:/var/lib/mysql --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=llqwe mysql:latest Redis\n1docker run -d --name=redis -p 6379:6379 redis:alpine ","date":"2021-09-02","img":"","permalink":"/programming/docker-webservice/","series":null,"tags":["Docker"],"title":"Docker Webservice"},{"categories":["编程开发"],"content":"1 { 2 \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://rh3ppqdn.mirror.aliyuncs.com\u0026#34;] 3 } ","date":"2021-09-02","img":"","permalink":"/programming/docker-registry/","series":null,"tags":["Docker"],"title":"Docker阿里云镜像配置"},{"categories":["编程开发"],"content":"1[user] 2\tname = 用户名 3\temail = 邮箱 4[credential] 5\thelper = manager 6 7[alias] 8\tst = status 9\tco = checkout 10\tci = commit 11\tbr = branch 12\tdi = diff 13[url \u0026#34;ssh://git@github.com/\u0026#34;] 14\tinsteadOf = https://github.com/ 15 ","date":"2021-09-02","img":"","permalink":"/programming/gitconfig/","series":null,"tags":["Git"],"title":"Git常用配置"},{"categories":[""],"content":"1go env -w GO111MODULE=auto 2go env -w GOPROXY=https://goproxy.cn,direct 3go env -w GOPRIVATE=*.example.com ","date":"2021-09-02","img":"","permalink":"/programming/goconfig/","series":null,"tags":["Golang"],"title":"Golang配置"},{"categories":[""],"content":"zsh自定义配置\n1#Tell ls to be colourful 2export CLICOLOR=1 3export LSCOLORS=\u0026#34;Gxfxcxdxbxegedabagacad\u0026#34; 4#Tell grep to highlight matches 5export GREP_OPTIONS=\u0026#39;--color=auto\u0026#39; 6# Enabling completion 7autoload -U compinit \u0026amp;\u0026amp; compinit 8# Enabling color prompt 9autoload -U colors \u0026amp;\u0026amp; colors 10# Enabling and setting git info var to be used in prompt config. 11autoload -Uz vcs_info 12zstyle \u0026#39;:vcs_info:*\u0026#39; enable git svn 13# This line obtains information from the vcs. 14zstyle \u0026#39;:vcs_info:git*\u0026#39; formats \u0026#34; - (%b)\u0026#34; 15precmd() { 16 vcs_info 17} 18 19# Enable substitution in the prompt. 20setopt prompt_subst 21 22# Config for the prompt. PS1 synonym. 23PROMPT=\u0026#39;[%{$fg_bold[green]%}%c%{$fg_bold[blue]%}${vcs_info_msg_0_}%{$reset_color%}]$ \u0026#39; 24 25export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles 26 27 28egrep=\u0026#39;egrep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox}\u0026#39; 29fgrep=\u0026#39;fgrep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox}\u0026#39; 30 31 32alias l=\u0026#34;ls -lah\u0026#34; 33alias la=\u0026#34;ls -lAh\u0026#34; 34alias ll=\u0026#34;ls -lh\u0026#34; ","date":"2021-09-02","img":"","permalink":"/programming/zshrc/","series":null,"tags":["Zsh"],"title":"Zsh配置"},{"categories":["编程开发"],"content":"以制作redis镜像为例，讲一下docker镜像制作及push到仓库流程\n1.编写Dockerfile 1FROMalpine:latest2# install redis3RUN apk add redis 4# expose port5EXPOSE63796# start redis server7CMD [\u0026#34;redis-server \u0026#34;]2.创建镜像 1docker build -t redis:0.0.1 . 3.登陆仓库 1docker login --username=username registry.cn-hangzhou.aliyuncs.com 4.镜像打标签 1 2docker tag redis:0.0.1 registry.cn-hangzhou.aliyuncs.com/jekst/redis:0.0.1 5.上传镜像 1docker push registry.cn-hangzhou.aliyuncs.com/jekst/redis:0.0.1 ","date":"2021-09-02","img":"","permalink":"/programming/create-docker-image/","series":null,"tags":["Docker"],"title":"自定义Docker镜像"},{"categories":["设计模式"],"content":"1.单一职责原则（Single Responsibility Principle，简称SRP ）  There should never be more than one reason for a class to change.\n 理解：不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。\n总结：一个类只承担一个职责\n2.里氏替换原则（Liskov Substitution Principle,简称LSP）  Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\n 理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。\n总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。\n3.依赖倒置原则（Dependence Inversion Principle,简称DIP）  High level modules should not depends upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.\n 理解：高层模块不应该依赖于底层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。\n4.接口隔离原则（Interface Segregation Principle,简称ISP）  The dependency of one class to another one should depend on the smallest possible interface.\n 理解：不要对外暴露没有实际意义的接口。也就是说，尽量保证接口的实用性。当需要对外暴露接口时，需要再三斟酌，若没必要对外提供就删了吧，因为一旦提供了就意味着，将来要多做一件事情，何苦给自己找事做呢。\n总结：不要对外暴露没有实际意义的接口。\n5.迪米特法则（Law of Demeter,简称LoD）  Only talk to you immediate friends.\n 理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。\n总结：一定要做到：低耦合、高内聚。\n6.开放封闭原则（Open Close Principle,简称OCP）  Software entities like classes,modules and functions should be open for extension but closed for modifications.\n 对扩展开放，对修改关闭。\n在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。\n","date":"2021-08-30","img":"","permalink":"/design-pattern/dp-principle/","series":null,"tags":[""],"title":"设计模式6大原则"},{"categories":["编程开发"],"content":"slice  每个切片都指向一个底层数组 每个切片都保存了当前切片的长度、底层数组可用容量 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片  map  map是并发不安全的 map遍历的顺序不固定 从map读取一个不存在的key将不会引起panic  chan  关闭值为nil的channel会引发panic 关闭值为nil的channel会引发panic 向已经关闭的channel或者nil的channel写数据会引发panic 可以从关闭的channel中读数据  iota  iota在const关键字出现时被重置为0 const声明块中每新增一行iota值自增1  简单理解：iota代表了const声明块的行索引（下标从0开始）\ndefer  defer定义的延迟函数参数在defer语句出时就已经确定下来了 defer定义顺序与实际执行顺序相反 defer可以改变return返回值，执行过程是: 保存返回值(若有)—\u0026gt;执行 defer（若有）—\u0026gt;执行ret跳转 申请资源后立即使用defer关闭资源是好习惯  select  select语句中除default外，每个case操作一个channel，要么读要么写 select语句中除default外，各case执行顺序是随机的 select语句中如果没有default语句，则会阻塞等待任一case select语句中读操作要判断是否成功读取，关闭的channel也可以读  recover recover必须在defer中执行，并且不能在defer嵌套函数中 这样可以\n1func main(){ 2\tdefer func () { 3\terr:=recover() 4\t}() 5\tpanic(\u0026#34;some exception\u0026#34;) 6} 7 嵌套不可以\n1func main(){ 2\tdefer func () { 3\tfunc(){ 4 err:=recover() 5 } 6\t}() 7\tpanic(\u0026#34;some exception\u0026#34;) 8} 9 for range for range语句可以遍历数组、slice、map、chan\n 遍历slice时，循环内可以改变切片的长度，不影响循环次数，循环次效在循环开始前就已经确定了 遍历chan时，chan关闭后会退出循环；如果channel中没有数据，可能会阻塞 遍历map时，遍历的顺序不固定，是随机的，循环内插入的数据不一定能遍历到，最好不要在遍历时对map进行写操作 使用index,value接收range返回值会发生一次数据拷贝，遍历过程中可以适情况放弃接收index或value，可以一定程度上提升性能。数组、slice可以放弃value，避免value拷贝。  Golang中的引用类型  切片 map channel interface  Golang中的指针运算  可以通过“\u0026amp;”取指针的地址 可以通过“*”取指针指向的数据  Golang main函数  main函数不能带参数 main函数不能定义返回值 main函数所在的包必须为main包 main函数中可以使用flag包来获取和解析命令行参数  ","date":"2021-08-29","img":"","permalink":"/programming/go-feature/","series":null,"tags":["Golang"],"title":"Go语言特性"},{"categories":["操作系统"],"content":"进程 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。\n线程 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。\n协程 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 区别： 进程与线程比较 线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:\n 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源 线程是处理器调度的基本单位,但进程不是 二者均可并发执行 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制  协程与线程进行比较  一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。 线程进程都是同步机制，而协程则是异步 3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态  ","date":"2021-08-29","img":"","permalink":"/os/process-thread-coroutine/","series":null,"tags":["HTTP"],"title":"进程、线程和协程"}]