<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Jekst</title><link>/tags/golang/</link><description>Recent content in Golang on Jekst</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2016-{year} Jekst. All Rights Reserved.</copyright><lastBuildDate>Thu, 02 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang配置</title><link>/programming/goconfig/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/goconfig/</guid><description>1go env -w GO111MODULE=auto 2go env -w GOPROXY=https://goproxy.cn,direct 3go env -w GOPRIVATE=*.example.com</description></item><item><title>Go语言特性</title><link>/programming/go-feature/</link><pubDate>Sun, 29 Aug 2021 13:23:24 +0800</pubDate><guid>/programming/go-feature/</guid><description>slice 每个切片都指向一个底层数组 每个切片都保存了当前切片的长度、底层数组可用容量 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片 map map是并发不安全的 map遍历的顺序不固定 从map读取一个不存在的key将不会引起panic chan 关闭值为nil的channel会引发panic 关闭值为nil的channel会引发panic 向已经关闭的channel或者nil的channel写数据会引发panic 可以从关闭的channel中读数据 iota iota在const关键字出现时被重置为0 const声明块中每新增一行iota值自增1 简单理解：iota代表了const声明块的行索引（下标从0开始）
defer defer定义的延迟函数参数在defer语句出时就已经确定下来了 defer定义顺序与实际执行顺序相反 defer可以改变return返回值，执行过程是: 保存返回值(若有)—&amp;gt;执行 defer（若有）—&amp;gt;执行ret跳转 申请资源后立即使用defer关闭资源是好习惯 select select语句中除default外，每个case操作一个channel，要么读要么写 select语句中除default外，各case执行顺序是随机的 select语句中如果没有default语句，则会阻塞等待任一case select语句中读操作要判断是否成功读取，关闭的channel也可以读 recover recover必须在defer中执行，并且不能在defer嵌套函数中 这样可以
1func main(){ 2 defer func () { 3 err:=recover() 4 }() 5 panic(&amp;#34;some exception&amp;#34;) 6} 7 嵌套不可以
1func main(){ 2 defer func () { 3 func(){ 4 err:=recover() 5 } 6 }() 7 panic(&amp;#34;some exception&amp;#34;) 8} 9 for range for range语句可以遍历数组、slice、map、chan</description></item></channel></rss>