<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jekst</title><link>/</link><description>Recent content on Jekst</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2016-{year} Jekst. All Rights Reserved.</copyright><lastBuildDate>Sun, 12 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Markdown简明教程</title><link>/posts/markdown-syntax/</link><pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/markdown-syntax/</guid><description>1.标题 Markdown支持6种级别的标题，对应html标签 h1 ~ h6,注意符号“#”和“H”之间有空格
# H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 效果：
H1 H2 H3 H4 H5 H6 2.段落 段落没有特殊的格式，直接编写文字就可以，段落的换行是使用两个以上空格加上回车。
也可以使用一个或多个空行。
2.1.字体 *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 效果如下：
斜体文本
斜体文本
粗体文本
粗体文本
粗斜体文本
2.2.分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：
*** * * * ***** - - - ---------- 效果如下：
2.3.删除线 文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</description></item><item><title>TCP协议总结</title><link>/network/tcp/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate><guid>/network/tcp/</guid><description>传输控制协议（Transmission Control Protocol，TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，
1.TCP特点 TCP时面向连接的传输层协议。 TCP只支持一对一通信。 TCP提供可靠交付的服务。通过TCP传送的数据，无差错、不丢失、不重复、并且按序到达。 TCP提供全双工通信。 TCP是面向字节流的。 为满足TCP协议的这些特点，TCP协议做了如下的规定：
①数据分片：在发送端对用户数据进行分片，在接收端进行重组，由TCP确定分片的大小并控制分片和重组；
②到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认；
③超时重发：发送方在发送分片时启动超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片；
④滑动窗口：TCP连接每一方的接收缓冲空间大小都固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出；
⑤失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层；
⑥重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据；
⑦数据校验：TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验和有差错，TCP将丢弃这个分片，并不确认收到此报文段导致对端超时并重发。
2.TCP首部格式 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source Port | Destination Port | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Acknowledgment Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Data | |U|A|P|R|S|F| | | Offset| Reserved |R|C|S|S|Y|I| Window | | | |G|K|H|T|N|N| | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Checksum | Urgent Pointer | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Options | Padding | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | data | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Source Port是源端口，16位。 Destination Port是目的端口，16位。 Sequence Number是发送数据包中的第一个字节的序列号，32位。 Acknowledgment Number是确认序列号，32位。 Data Offset是数据偏移，4位，该字段的值是TCP首部（包括选项）长度除以4。 标志位： 6位，URG表示Urgent Pointer字段有意义： ACK表示Acknowledgment Number字段有意义 PSH表示Push功能，RST表示复位TCP连接 SYN表示SYN报文（在建立TCP连接的时候使用） FIN表示没有数据需要发送了（在关闭TCP连接的时候使用） Window表示接收缓冲区的空闲空间，16位，用来告诉TCP连接对端自己能够接收的最大数据长度。 Checksum是校验和，16位。 Urgent Pointers是紧急指针，16位，只有URG标志位被设置时该字段才有意义，表示紧急数据相对序列号（Sequence Number字段的值）的偏移。 3.</description></item><item><title>UDP协议总结</title><link>/network/udp/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate><guid>/network/udp/</guid><description>1.UDP概述 用户数据报协议（User Datagram Protocol，UDP），主要有以下特点：
UDP是无连接的，发送数据前不需要建立连接，结束后也不需要释放链接，因此减少了开销和发送数据之前的延迟 UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维护复杂的连接状态参数。 UDP是面向报文的。 UDP没有拥塞控制。 UDP支持一对一、一对多、多对一、多对多对交互通信。 UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。 2.UDP首部格式 0 7 8 15 16 23 24 31 +--------+--------+--------+--------+ | Source | Destination | | Port | Port | +--------+--------+--------+--------+ | | | | Length | Checksum | +--------+--------+--------+--------+ | | data octets ... +---------------- ... Source Port 源端口号，在需要对方回信时选用。不需要时可全为0，可选字段。 Destination Port 目的端口号。在终点交付报文时必须要使用到。 Length UDP用户数据报的长度，包括首部和数据长度，其最小值是8（仅有首部）。 Chechsum 校验和，检测UDP用户数据报在传输中是否有错。有错就丢弃。</description></item><item><title>brew阿里源配置</title><link>/programming/brew/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/brew/</guid><description>Bash 终端配置 1 # 替换brew.git: 2 cd &amp;#34;$(brew --repo)&amp;#34; 3 git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git 4 # 替换homebrew-core.git: 5 cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34; 6 git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git 7 # 应用生效 8 brew update 9 # 替换homebrew-bottles: 10 echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&amp;#39; &amp;gt;&amp;gt; ~/.bashrc 11 source ~/.bashrc Zsh 终端配置 1 # 替换brew.git: 2 cd &amp;#34;$(brew --repo)&amp;#34; 3 git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git 4 # 替换homebrew-core.git: 5 cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34; 6 git remote set-url origin https://mirrors.</description></item><item><title>HTTP响应码</title><link>/network/http-code/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0000</pubDate><guid>/network/http-code/</guid><description> Code Reason-Phrase 100 Continue 101 Switching Protocols 200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 305 Use Proxy 307 Temporary Redirect 400 Bad Request 401 Unauthorized 402 Payment Required 403 Forbidden 404 Not Found 405 Method Not Allowed 406 Not Acceptable 407 Proxy Authentication Required 408 Request Timeout 409 Conflict 410 Gone 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 417 Expectation Failed 426 Upgrade Required 500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 505 HTTP Version Not Supported</description></item><item><title>Docker Webservice</title><link>/programming/docker-webservice/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/docker-webservice/</guid><description>Mysql
1docker run -d -v /Users/User/data/dbdata:/var/lib/mysql --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=llqwe mysql:latest Redis
1docker run -d --name=redis -p 6379:6379 redis:alpine</description></item><item><title>Docker阿里云镜像配置</title><link>/programming/docker-registry/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/docker-registry/</guid><description>1 { 2 &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://rh3ppqdn.mirror.aliyuncs.com&amp;#34;] 3 }</description></item><item><title>Git常用配置</title><link>/programming/gitconfig/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/gitconfig/</guid><description>1[user] 2 name = 用户名 3 email = 邮箱 4[credential] 5 helper = manager 6 7[alias] 8 st = status 9 co = checkout 10 ci = commit 11 br = branch 12 di = diff 13[url &amp;#34;ssh://git@github.com/&amp;#34;] 14 insteadOf = https://github.com/ 15</description></item><item><title>Golang配置</title><link>/programming/goconfig/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/goconfig/</guid><description>1go env -w GO111MODULE=auto 2go env -w GOPROXY=https://goproxy.cn,direct 3go env -w GOPRIVATE=*.example.com</description></item><item><title>Zsh配置</title><link>/programming/zshrc/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/zshrc/</guid><description>zsh自定义配置
1#Tell ls to be colourful 2export CLICOLOR=1 3export LSCOLORS=&amp;#34;Gxfxcxdxbxegedabagacad&amp;#34; 4#Tell grep to highlight matches 5export GREP_OPTIONS=&amp;#39;--color=auto&amp;#39; 6# Enabling completion 7autoload -U compinit &amp;amp;&amp;amp; compinit 8# Enabling color prompt 9autoload -U colors &amp;amp;&amp;amp; colors 10# Enabling and setting git info var to be used in prompt config. 11autoload -Uz vcs_info 12zstyle &amp;#39;:vcs_info:*&amp;#39; enable git svn 13# This line obtains information from the vcs. 14zstyle &amp;#39;:vcs_info:git*&amp;#39; formats &amp;#34; - (%b)&amp;#34; 15precmd() { 16 vcs_info 17} 18 19# Enable substitution in the prompt.</description></item><item><title>自定义Docker镜像</title><link>/programming/create-docker-image/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>/programming/create-docker-image/</guid><description>以制作redis镜像为例，讲一下docker镜像制作及push到仓库流程
1.编写Dockerfile 1FROMalpine:latest2# install redis3RUN apk add redis 4# expose port5EXPOSE63796# start redis server7CMD [&amp;#34;redis-server &amp;#34;]2.创建镜像 1docker build -t redis:0.0.1 . 3.登陆仓库 1docker login --username=username registry.cn-hangzhou.aliyuncs.com 4.镜像打标签 1 2docker tag redis:0.0.1 registry.cn-hangzhou.aliyuncs.com/jekst/redis:0.0.1 5.上传镜像 1docker push registry.cn-hangzhou.aliyuncs.com/jekst/redis:0.0.1</description></item><item><title>设计模式6大原则</title><link>/design-pattern/dp-principle/</link><pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate><guid>/design-pattern/dp-principle/</guid><description>1.单一职责原则（Single Responsibility Principle，简称SRP ） There should never be more than one reason for a class to change.
理解：不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。
总结：一个类只承担一个职责
2.里氏替换原则（Liskov Substitution Principle,简称LSP） Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.
理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。
总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。
3.依赖倒置原则（Dependence Inversion Principle,简称DIP） High level modules should not depends upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.</description></item><item><title>Go语言特性</title><link>/programming/go-feature/</link><pubDate>Sun, 29 Aug 2021 13:23:24 +0800</pubDate><guid>/programming/go-feature/</guid><description>slice 每个切片都指向一个底层数组 每个切片都保存了当前切片的长度、底层数组可用容量 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片 map map是并发不安全的 map遍历的顺序不固定 从map读取一个不存在的key将不会引起panic chan 关闭值为nil的channel会引发panic 关闭值为nil的channel会引发panic 向已经关闭的channel或者nil的channel写数据会引发panic 可以从关闭的channel中读数据 iota iota在const关键字出现时被重置为0 const声明块中每新增一行iota值自增1 简单理解：iota代表了const声明块的行索引（下标从0开始）
defer defer定义的延迟函数参数在defer语句出时就已经确定下来了 defer定义顺序与实际执行顺序相反 defer可以改变return返回值，执行过程是: 保存返回值(若有)—&amp;gt;执行 defer（若有）—&amp;gt;执行ret跳转 申请资源后立即使用defer关闭资源是好习惯 select select语句中除default外，每个case操作一个channel，要么读要么写 select语句中除default外，各case执行顺序是随机的 select语句中如果没有default语句，则会阻塞等待任一case select语句中读操作要判断是否成功读取，关闭的channel也可以读 recover recover必须在defer中执行，并且不能在defer嵌套函数中 这样可以
1func main(){ 2 defer func () { 3 err:=recover() 4 }() 5 panic(&amp;#34;some exception&amp;#34;) 6} 7 嵌套不可以
1func main(){ 2 defer func () { 3 func(){ 4 err:=recover() 5 } 6 }() 7 panic(&amp;#34;some exception&amp;#34;) 8} 9 for range for range语句可以遍历数组、slice、map、chan</description></item><item><title>进程、线程和协程</title><link>/os/process-thread-coroutine/</link><pubDate>Sun, 29 Aug 2021 13:23:24 +0800</pubDate><guid>/os/process-thread-coroutine/</guid><description>进程 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
线程 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
协程 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 区别： 进程与线程比较 线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:
地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源 线程是处理器调度的基本单位,但进程不是 二者均可并发执行 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 协程与线程进行比较 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。 线程进程都是同步机制，而协程则是异步 3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</description></item></channel></rss>